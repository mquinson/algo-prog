\documentclass[10pt]{article}\usepackage[correction,nu]{esial}
%\documentclass[10pt]{article}\usepackage{esial}
\TOP\unA

\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{amstext,amsmath,amsfonts}
\usepackage{fancyvrb}

\begin{document}
\color{black}
\title{TD6 : Preuve de programmes}
\maketitle

\begin{Reponse}
  Le plus intéressant à faire est l'exercice 2, puisque l'algorithme à démontrer
  est faux. On en a pour une grosse heure de calcul à le montrer, mais en
  général, le résultat tombe comme un coup de tonnerre. Ceux qui se moquait de
  la pénibilité de la preuve formelle ``pour un code aussi simple que ça'' sont
  bien étonnés quand on montre qu'il est faux. \textbf{Il ne faut pas leur dire
    à l'avance: ne spoilez pas le TD!}
\end{Reponse}

% \noindent On rappelle les règles d'inférence de la logique de Hoare:


% $$\frac{}{\{P\} skip \{P\}} ~~~~~~~~~~  \frac{}{\{P[x/E]\} x:=E \{P\}} ~~~~~~~~~~
% \frac{P\Rightarrow P', \{P\} ~C~ \{Q\}, Q\Rightarrow Q'}{\{P'\} ~C~ \{Q'\}}$$

% $$\hspace{-14mm}\frac{\{P\} C_1 \{Q\},~~ \{Q\} C_2 \{R\}}{\{P\} C_1;C_2 \{R\}}
%  ~~~~~~~
% \frac{\{P\wedge Cond\} ~T~ \{Q\},~~ \{P\wedge\neg Cond\} ~E~
%       \{Q\}}{\{P\} \mathbf{~if~} Cond \mathbf{~then~} T \mathbf{~else~} E \mathbf{~endif~} \{Q\}}
% ~~~~~~~
% \frac{\{I\wedge Cond\wedge V=z\} ~L~ \{I\wedge V<z\}~,~I\Rightarrow V\geq0}
%             {\{I\} \mathbf{~while~} Cond \mathbf{~do~} 
%                    L \mathbf{~endif~} \{I\wedge\neg Cond\}}$$    

% $P$, $Q$, $I$ et $Cond$ sont des assertions sans effet de bord. $C$, $C_1$,
% $C_2$, $T$ et $L$ sont des instructions. V est un variant, c'est à dire une
% variable entière du pseudo-code. Ce que la règle de la boucle indique, c'est
% que le variant est initialement égal à une valeur arbitraire $z$, et que sa
% valeur décroit strictement à chaque itération de la boucle. Ce point est
% indispensable pour montrer la terminaison de l'algorithme.

% \Exercice \textbf{Calcul de la racine carrée} (d'après Hayssam Soueidan).

% \noindent\begin{minipage}{.65\linewidth}
%   ~~~On considère le programme ci-contre. Nous allons montrer avec le calcul de
%   Hoare qu'il calcule la racine carrée. Plus précisément, qu'il est
%   partiellement correct par rapport à la précondition $(x\geq0)$ et à la
%   post-condition $(y_1\times y_1\leq x)\wedge((y_1+1)\times (y_1+1)> x)$

  
%   ~~Appelons $S_0$ le sous-programme constitué des 3 premières instructions, et S
%   le sous-programme qui forme le corps de la boucle.
% \end{minipage}\hfill%
% \begin{minipage}{.3\linewidth}
% \begin{Verbatim}
%   y1:=0
%   y2:=1
%   y3:=1
%   while y3<=x do
%     y1 := y1 + 1
%     y2 := y2 + 2
%     y3 := y3 + y2
%   done
% \end{Verbatim}  
% \end{minipage}

% \Question Calculez les valeurs que prennent les variables $y_1$, $y_2$, $y_3$
% pour les premières itérations de la boucle while. Conjecturer les valeurs de
% $y_2$ et $y_3$ en fonction de $y_1$. On note $P$ la conjonction de ces deux
% égalités et de $(y_1\times y_1 \leq x)$

% \begin{Reponse}
%   $y_2=2\times y_1 + 1$ et $y_3=(y_1+1)^2$. On a donc:
%   $\underbrace{(y_2=2\times y_1 +
%     1)}\wedge\underbrace{(y_3=(y_1+1)^2)}\wedge\underbrace{(y_1\times y_1 \leq
%     x)}$

%   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$p_1$
%   ~~~~~~~~~~~~~~~~~~~~~$p_2$
%   ~~~~~~~~~~~~~~~~~~$p_3$
% \end{Reponse}

% \Question $P$ va être l'invariant de la boucle. C'est ce que l'on va montrer en
% utilisant la règle d'inférence du while.

% Écrire la prémise que l'on doit utiliser, et montrer qu'elle est valide.
% Indication: partir de la post-condition pour trouver les conditions
% intermédiaires. 

% \begin{Reponse}
%   On part de la fin de $S$. C'est une séquence, cela nous donne:

%   \begin{center}
%     \begin{tabular}{ccc}
%       $\{p'\}$&$y_3:=y_3+y_2$&$\{p\}$\\
%       $\{p''\}$&$y_2:=y_2+2$&$\{p'\}$\\
%       $\{p'''\}$&$y_1:=y_1+1$&$\{p''\}$\\
%     \end{tabular}
%   \end{center}

%   En appliquant la règle d'affectation, et en effectuant les réécritures
%   qu'elle impose, on trouve:

%   \begin{center}
%     \begin{tabular}{c@{~$\equiv$~}c@{~$\wedge$~}c@{~$\wedge$~}c}
%       $P$   &$(y_2=2\times y_1 + 1)$&$(y_3=(y_1+1)^2)$&$(y_1\times y_1 \leq x)$\\
%       $P$   &$p_1$&$p_2$&$p_3$\\
%       $p'$  &$p_1$&$(y_3+y_2=(y_1+1)^2$&$p_3$\\
%       $p''$ &$(y_2+2=2\times y_1+1)$&$(y_3+y_2+2=(y_1+1)^2$&$p_3$\\
%       $p'''$&$(y_2+2=2\times (y_1+1)+1)$&$(y_3+y_2+2=(y_1+2)^2$&$((y_1+1)^2 \leq x)$\\
%     \end{tabular}
%   \end{center}
  
%   Par composition, on a donc: $\{p'''\} S \{P\}$. 
%   Un peu d'arithmétique sur la définition de $p'''$ nous donne:
%   $p'''\equiv (y_2=2\times y_1+1)\wedge(y_3+2\times y_1+1+2=y_1^2+4y_1+4)\wedge((y_1+1)^2 \leq x)$\\
%   $p'''\equiv (p_1)\wedge(y_3=y_1^2+2y_1+1)\wedge((y_1+1)^2 \leq x)$ \\
%   $p'''\equiv (p_1)\wedge(y_3=(y_1+1)^2)\wedge(y_3 \leq x)$ \\
%   $p'''\equiv (p_1)\wedge(p_2)\wedge(y_3 \leq x)$. Mais cette formule est une
%   conséquence de $\{P\wedge(y_3 \leq x)\}$ \\

%   Avec la règle de la conséquence, on trouve donc la prémisse $\{P\wedge(y_3 \leq x)\}$ 
% \end{Reponse}

% \Question Montrez que $P$ est vérifiée après les 3 premières instructions du
% programme, sous la condition $(x\geq0)$. On veut donc montrer que $\{x\geq0\}
% S_0 \{P\}$ est valide.
% \begin{Reponse}
%   En remontant, on obtient facilement (à lire de bas en haut, donc):

%   \begin{tabular}{rcl}
%     $\{(1=1)\wedge(1=1)\wedge(0\leq x)\}$&$y_1:=0$&
%     $\{(1=2\times y_1+1)\wedge(1=(y_1+1)^2)\wedge p_3\}$\\

%     $\{(1=2\times y_1+1)\wedge(1=(y_1+1)^2)\wedge p_3\}$&$y_2:=1$&
%     $\{p_1\wedge(1=(y_1+1)^2)\wedge p_3\}$\\

%     $\{p_1\wedge(1=(y_1+1)^2)\wedge p_3\}$&$y_3:=1$&$\{P\}$\\
%   \end{tabular}

%   La première condition étant équivalente à $r\geq0$, on en conclut par les
%   règles de conséquence et de composition que $\{x\geq0\}S_0\{P\}$ est valide.
% \end{Reponse}

% \Question Concluez.
% \begin{Reponse}
%   En composant les deux morceaux, on obtient la validité de:

%   \begin{tabular}{rcl}
%     $\{x\geq0\}$&$Code$&$\{P\wedge y_3>x\}$\\    
%     $\{x\geq0\}$&$Code$&$\{(y_2=2\times y_1 +
%     1)\wedge(y_3=(y_1+1)^2)\wedge(y_1\times y_1 \leq x)\wedge (y_3>x)\}$\\     
%     $\{x\geq0\}$&$Code$&$\{(y_2=2\times y_1 + 1)\wedge(y_1^2 \leq x)\wedge ((y_1+1)^2>x)\}$\\     
%     $\{x\geq0\}$&$Code$&$\{(y_1^2 \leq x)\wedge ((y_1+1)^2>x)\}$\\     
%   \end{tabular}

%   Ouf.
% \end{Reponse}

\medskip
\newcommand{\WP}[1]{\textbf{WP}($#1$)}

Dans ce TD, nous allons démontrer que les algorithmes étudiés sont corrects en
calculant la plus faible précondition nécessaire (\textit{weakest precondition})
pour que l'algorithme donne bien dans la post-condition souhaitée (le résultat
est celui attendu). Cette méthode est l'une des plus simples et mécaniques pour
démontrer formellement la correction d'algorithmes. Pour cela, il faut appliquer
les cinq règles suivante.

\medskip\noindent\framebox{\vbox{\begin{enumerate}
\item \WP{no-op, Q}  $\equiv Q$
\item \WP{x:=E, Q} $\equiv Q[x:=E]$
\item \WP{C;D, Q}  $\equiv$ \WP{C, \WP{D,Q}}
\item \textbf{WP}(\texttt{if} $Cond$ \texttt{then} $C$ \texttt{else} $D$)
  $\equiv (Cond=\mathtt{true}\Rightarrow \mathbf{WP}(C,Q))~\wedge~
          (Cond=\mathtt{false}\Rightarrow \mathbf{WP}(D,Q))$
\item \textbf{WP}(\texttt{while} $E$ \texttt{do} $C$ \texttt{done} \{inv I var V\},Q)
  $\equiv I$\\
  Plus les obligations de preuves suivantes:
  \begin{itemize}
  \item[$\bullet$] $(E=\mathtt{true}\wedge I\wedge V=z) \Rightarrow
    \mathbf{WP}(C,I\wedge V<z))$
    (preuve que chaque passage décrémente le variant)
  \item[$\bullet$] $I\Rightarrow V\geq 0$
    % 
    \hfill (preuve que le variant reste valide lors les passages successifs)
  \item[$\bullet$] $(E=\mathtt{false}\wedge I) \Rightarrow Q$
    %
    \hfill (preuve qu'après le dernier passage, Q est bien atteint)
  \end{itemize}
\end{enumerate}
}}

La première règle signifie que la plus faible précondition à assurer pour que $Q$
soit vraie après l'exécution de \texttt{no-op} (après l'exécution de rien du
tout) est $Q$ elle-même.

La seconde règle explicite les affectations de variable: Pour que $Q$ soit vraie
après une affectation, il faut que $Q$ soit vraie au préalable avec une
réécriture.

La troisième règle indique que la plus faible précondition permettant que $Q$
soit vraie après l'exécution de \texttt{C} puis \texttt{D}, c'est la
précondition à \texttt{C} pour \WP{D,Q} soit vrai, c'est à dire pour que soit
vérifiée la précondition de D permettant à $Q$ d'être vraie.

La quatrième règle est plus facile à écrire avec l'écriture mathématique qu'avec
une paraphrase.

La cinquième règle, au sujet des boucles, n'est pas très compliquée non plus,
mais elle impose d'annoter chaque boucle \texttt{while} par un invariant et un
variant (syntaxe: $\{inv ~I~ var ~V\}$). Par ailleurs, l'application de cette
règle produit trois obligations de preuves supplémentaires. Il s'agit
d'expression qu'il faudra démontrer par ailleurs pour avoir le droit d'appliquer
la règle de calcul du \textbf{WP}.

\smallskip
\noindent\begin{minipage}{.83\linewidth}
Ensemble, ces cinq règles permettent de démontrer le triplet de Hoare
\fbox{\{P\} C \{Q\}} en montrant la proposition \fbox{$P\Rightarrow \WP{C,Q}$}
ainsi que toutes les obligations de preuves engendrées lors du calcul de
\WP{C,Q}.

\Exercice \textbf{Fibonnacci} (d'après Ralf Treinen).

  Calculez la plus faible précondition pour que code donné ci-contre admette
  comme post-condition que $a=fib(n)$ (ie, que l'algorithme calcule Fibonacci
  de n dans $a$).  
\end{minipage}\hfill%
\begin{minipage}{.16\linewidth}
\begin{Verbatim}[gobble=2,label=FIB,numbers=right]
  i:=1
  a:=1
  b:=1
  while i<n do
    i:=i+1
    u:=a
    a:=a+b
    b:=u
  done
\end{Verbatim}  
\end{minipage}

\begin{Reponse}
  On note $Q\equiv a=f_n$, et l'objectif de l'exercice est de calculer

  $$WP(L1-L9, Q)\equiv ??$$

  Allégorie explicative: Q est un endroit du monde des idées, et le code est une
  trajectoire. Le but de l'exo est de calculer de où on peut partir pour que
  cette trajectoire nous amène à l'objectif Q.

  On commence par couper cette expression en remontant le calcul du WP de proche
  en proche en commençant par la fin de l'algo. Ici, le premier bloc qu'on
  décroche est toute la boucle while.
  
  $$WP(L1-L9, Q)\equiv WP(L1-L3, WP(L4-L9,Q))$$

  Il faut donc calculer \framebox{$WP(L4-L9,Q)$}, qui est la précondition de la
  boucle. On commence par cherche l'invariant de la boucle. Voici des
  \textbf{indices pour trouver l'invariant}:

  \begin{itemize}
  \item Il doit y avoir assez d'infos dans l'invariant pour parvenir à démontrer
    la post-condition quand on sort de la boucle. Cf. obligation de preuve 2:
    $(E=\mathtt{false}\wedge I) \Rightarrow Q$ \\
    On a donc intérêt à mettre Q en changeant les $n$ par l'indice de boucle si
    c'est vrai. On vérifie au passage que le code va bien (1) rendre vraies ces
    conditions quand on se présente à la boucle (2) maintenir ces conditions
    dans la boucle
  \item On a intérêt à mettre toutes les infos qu'on sait vrai. On a jamais trop
    d'infos dans l'invariant. En particulier, il faut parler des bornes sur
    l'indice de boucle.
  \end{itemize}

  Ici, on a \framebox{$I\equiv (0\leq i\leq n)\wedge a=f_i \wedge b=f_{i-1}$}

  Pour \textbf{trouver le variant}, c'est juste la formalisation de ce qu'on
  disait pour la terminaison des algos recursifs: il y a une grandeur qui
  commence positive, et qui décroit strictement vers 0. C'est ça qu'on appelle
  le variant. Ici, on a \framebox{V=n-i}

  On est presque prêts à appliquer la règle 5 pour affirmer que 

  $$WP(L4-L9,Q)\equiv I \text{ et donc que } WP(L1-L9,Q)\equiv WP(L1-L3, I)$$

  On a ``juste'' 3 obligations de preuves:
  \begin{enumerate}
  \item $(i<n) \wedge I \wedge (n-i=z)\Rightarrow \mathbf{WP}(L5-L8, I\wedge n-i<z)$
  \item $I\Rightarrow n-i\geq0$
  \item $(i\geq n) \wedge I\Rightarrow Q$
  \end{enumerate}

  \paragraph{Obligation 2:} 
  Après avoir changé I par sa définition, il faut montrer que:

  $$(0\leq i\leq n)\wedge (a=f_i) \wedge (b=f_{i-1})\Rightarrow (n-i\geq0)$$

  On peut oublier les bouts à gauche qui parlent de $a$ et $b$, le premier bout
  $(0\leq i\leq n)$ suffit à montrer la partie droite de l'implication. CQFD.

  \paragraph{Obligation 3:} 
  Après avoir changé I et Q par leurs définitions, il faut montrer que:

  $$(i\geq n) \wedge (0\leq i\leq n) \wedge (a=f_i) \wedge (b=f_{i-1})\Rightarrow (a=f_n)$$

  Les deux premiers bouts imposent que $i=n$, ce qui, ajouté à $a=f_i$ montre bien que $a=f_n$. CQFD.

  \paragraph{Obligation 1:} On est chaud, on se lance sur le gros bout.

  $$(i<n) \wedge (0\leq i\leq n) \wedge (a=f_i) \wedge (b=f_{i-1}) \wedge (n-i=z)$$
  $$ \Rightarrow$$
  $$ WP\left(L5-L9, (0\leq i\leq n) \wedge (a=f_i) \wedge (b=f_{i-1}) \wedge (n-i<z)\right)$$

  J'applique la règle 3 pour couper la ligne 8, puis la règle 2 pour appliquer
  la réécriture de l'affectation de variable où $b$ prend la vieille version de
  $a$, c'est à dire $f_i$.

  $$ \text{(membre gauche de l'implication)} \Rightarrow WP\left(L5-L7, (0\leq i\leq n) \wedge (a=f_i) \wedge (b=f_i) \wedge (n-i<z)\right)$$

  Encore une fois les règles 3 puis 2 pour l'affectation de $a$ à $f_i+f_{i-1}$,
  c'est à dire \framebox{$a=f_{i+1}$} en appliquant la définition mathématique de fibo.

  $$ \text{(membre gauche de l'implication)} \Rightarrow WP(L5-L6, (0\leq i\leq n) \wedge (a=f_{i+1}) \wedge (b=f_i) \wedge (n-i<z)$$ 

  On ignore la ligne 6 qui parle d'une variable temporaire, et on incrémente
  $i$. On écrit $i+1$ partout où la variable $i$ apparait. Attention, on ne
  change pas les $i$ dans $f_i$, puisque c'est pas la variable (libre) $i$, mais
  une autre variable nomée $f_i$ Vous ne voudriez pas remplacer la variable
  $min$ en la variable $mi-1n$, si?

  Mais \textbf{attention} pour que $f_i$ continue de désigner la même grandeur
  (par exemple $f_4$) tandis que la valeur de $i$ s'incrémente (de 4 à 5), il
  faut remplacer l'écriture $f_i$ par $f_{i-1}$. Oui, c'est pas évident...

  $$ \text{(membre gauche de l'implication)} \Rightarrow (0\leq i+1\leq n) \wedge (a=f_i) \wedge (b=f_{i-1}) \wedge (n-i-1<z)$$ 

  On a fini de calculer le membre droit. On range les éléments sur $i$ à gauche
  et on doit donc démontrer:

   $$(n-i=z) \wedge (0\leq i< n)\wedge (a=f_i) \wedge (b=f_{i-1})
   \Rightarrow (0\leq i+1\leq n)\wedge (a=f_i) \wedge
   (b=f_{i-1})\wedge (n-i-1<z)$$

   Considérons séparément tous les bouts du membre droit pour voir s'ils sont vrais:

   \begin{itemize}
   \item $0\leq i+1\leq n$: on a ça trivialement depuis le $(0\leq i< n)$
     présent à gauche.
   \item $a=f_i$: présent à l'identique à gauche
   \item $b=f_{i-1}$: présent à l'identique à gauche
   \item $n-i-1<z$: À gauche, on a $n-i=z$ donc trivialement.
   \end{itemize}

   \bigskip %
   Et voila, \textbf{on a démontré les 3 obligations de preuves}. On peut
   affirmer ce qui suit et continuer.

  $$WP(L1-L9,Q)\equiv WP(L1-L3, I)\equiv WP(L1-L3, (0\leq i\leq n)\wedge a=f_i \wedge b=f_{i-1}) )$$

  On applique les règles 3 puis 2 pour séparer puis traiter les lignes
  d'initialisation. Ce sont des réécritures \framebox{$i \rightarrow 1$} et
  \framebox{$a \rightarrow 1$} et \framebox{$b \rightarrow 1$}

  $$WP(L1-L9,Q)\equiv (0\leq 1\leq n)\wedge (1=f_1) \wedge (1=f_0)$$

  Les deux derniers bouts de la précondition sont vrais par définition
  mathématique de fibo, il ne reste donc que \framebox{$P\equiv n>0$}

  Voilà, tout va bien. On peut même relacher un peu la contrainte et constater
  que l'algo fonctionne encore pour une condition un peu plus forte, quand
  $n\geq 0$ Pour cela, on constate que dans ce cas, la boucle ne s'exécute pas
  et on ne fait que les initialisations, ce qui est suffisant pour atteindre le
  résultat.
\end{Reponse}

\ifcorrection{\newpage}{\medskip}
\Exercice \textbf{Calcul du minimum} (d'après Alexandre Miquel).

\smallskip
\noindent\begin{minipage}{.67\linewidth}
  On considère le code ci-contre, qui calcule le minimum d'une fonction entre 1
  et $n$.

  \Question Quelle est la spécification formelle de ce programme? Spécifiez en
  particulier la post-condition.

  \Question Trouvez l'invariant et le variant de la boucle while.
\end{minipage}\hfill%
\begin{minipage}{.31\linewidth}
\begin{Verbatim}[gobble=2,label=MIN,numbers=right]
  m:=f(1)
  i:=2
  while i<n do
    if (f(i)<m) then m:=f(i)
    i++
  done
\end{Verbatim}  
\end{minipage}

\begin{Reponse}
  Il faut donc tout d'abord spécifier la post-condition de façon un peu carré
  de façon à pouvoir le démontrer par la suite. On veut exprimer que $m$ est la 
  plus petite valeur de f sur l'intervale.

  \fbox{\textbf{Post} $\equiv (\exists u\in[1,n] ~tq~ m=f(u)) \wedge (\forall
  v\in[1,n], m\leq f(v))$}

On peut également donner la précondition révée (\fbox{\textbf{Pré} $\equiv
  n>0$}), mais le principe de la preuve avec les WP, c'est justement de calculer
la précondition nécessaire pour que ce code donne la post-condition. Donc, en
général, la précondition est un résultat de la preuve, pas un truc à
deviner. C'est d'ailleurs l'intérêt de la méthode.

Ensuite, il faut donner le variant. On regarde comment bouge l'indice $i$, et on
tripatouille pour que le variant bouge depuis un nombre non nul au début jusqu'à
0 à la fin. On va donc prendre \fbox{$V=n-i$}

Reste maintenant à deviner l'invariant. Il n'y a pas de méthode mécanique pour
cela. Il faut comprendre l'algorithme et voir pourquoi il fonctionne.
D'ailleurs, il est important d'insister auprès des élèves sur le fait que l'art
de trouver l'invariant est sans doute le bout de ce module qu'ils réutiliseront
le plus dans leur vie professionnelle. Quand l'algo est complexe (pas forcément
long, mais complexe), il est courant de mettre l'invariant de boucle dans la
documentation, pour aider les lecteurs à comprendre ce qui se passe, pourquoi ca
fonctionne.

Un indice pour deviner l'invariant ici, c'est qu'on va se retrouver à faire la
preuve suivante:
$$\{Pre\} \;\;Init\;\; \{P_{intermediaire}\} \;\;While\;\; \{Post\}$$

Pour cela, il serait plus simple si notre invariant ressemblait fortement à la
post-condition. Ca tombe bien, car si on regarde l'algo, il est construit pour
faire en sorte qu'à n'importe quelle étape $i$ de la boucle, on ait dans $m$
l'élément minimum de la partie du tableau à gauche de $i$, comme sur le dessin
suivant:

\centerline{\includegraphics{fig/invariant-minimum.fig}}

L'invariant à prendre pour que ca se passe bien est le suivant. C'est juste la
post-condition vérifiée sur les bouts au début du tableau.

\bigskip
\fbox{\textbf{Invariant} $\equiv(2\leq i\leq n)\wedge(\exists u\in[1,i] ~tq~
  m=f(u)) \wedge (\forall v\in[1,i], m\leq f(v))$}
\end{Reponse}

\Question Calculez les obligations de preuve correspondantes, et vérifiez
qu'elles sont satisfaites.

\begin{Reponse}
  C'est assez mécanique et un peu répétitif, mais le calcul des \textbf{WP}
  n'est pas très méchant au fond. Ce qui est drôle, c'est qu'ici, on va
  démontrer que ce code est faux. Encore plus fort: en ne parvenant pas à
  démontrer la correction du code, on va trouver un cas où il ne fonctionne pas,
  et on va même en déduire un correctif. 

  \textbf{Ne spoilez pas les étudiants, laissez leur la surprise}. Le calcul est
  assez pénible, autant qu'ils aient le choc de son intérêt à plein.

  \noindent
  \begin{minipage}{.7\linewidth}
    \includegraphics[width=\linewidth,angle=270]{TOP-seance6-preuve-1.JPG}    
  \end{minipage}\hspace{-2cm}
  \begin{minipage}{.4\linewidth}
    La preuve se déroule comme prévu, j'ai une post-condition, et je remonte
    mon code pour calculer la précondition nécessaire. Le code fini par une
    boucle while, et donc j'applique la règle 5 pour calculer les
    obligations de preuves avant de pouvoir affirmer que
    WP(while,post)=inv. 

    \bigskip
    Comme d'habitude, les obligations 2 et 3 sont très simples à monter, et la 1
    est bien plus dure. D'ailleurs, y'a un ptit bug au tableau puisque pour s'en
    sortir, il faut considérer que "if (cond) then { instr1 }" est en fait un
    "if (cond) then { instr1 } else {rien}". Ca semble pas important, mais ca
    change les éléments de preuves. Mais bon, après quelques réécritures, la
    partie droite de la première obligation de preuve (ie, la WP du corps de
    boucle) est l'expression K, en bas du tableau.
  \end{minipage}

  \noindent
  \begin{minipage}{.7\linewidth}
    \includegraphics[width=\linewidth,angle=270]{TOP-seance6-preuve-2.JPG}    
  \end{minipage}\hspace{-2cm}
  \begin{minipage}{.4\linewidth}
    Le haut de ce tableau-ci porte sur comment montrer que la première
    obligation de preuve tient, donc. On prend les bouts de K les uns après les
    autres, et à chaque fois qu'on en a un, on le raye. C'est gros, mais y'a
    rien de bien sorcier, en fait.
    
    \bigskip %
    Et sous le trait, maintenant que la dernière obligation est tombée, il ne
    nous reste plus qu'à finir de calculer les WP en remontant. Mais là, c'est
    l'échec: On ne peut pas propager le calcul des WP. Avec l'invariant qu'on a
    choisi (nécessaire pour la post-condition voulue), on se retrouve à dire que
    pour tout k dans [1,2], f(k)>=m alors que l'on a testé dans l'initialisation
    que pour k=1, et pas pour k=2...

    \bigskip
    Le tableau porte déjà les séquelles d'une tentative de correction : on a
    transformé [1;2] en [1;2[, mais du coup, l'invariant de boucle change en
    conséquence, ce qui change également la post-condition que l'on
    trouve. Donc, on a bien montré que si l'élément minimal est dans la
    dernière position, cet algorithme ne le trouve pas.
  \end{minipage}

\smallskip %
En reregardant l'algo, on voit tout de suite que la condition du while
est fausse: il faut utiliser i$<$=n au lieu de i$<$n. Avec cette
modification, on peut remodifier dans l'autre sens: on reprend la
post-condition qui nous intéresse, ca remet le premier invariant
trouvé, et on arrive cette fois à propager le calcul des WP jusqu'au
début de l'algo, sans anicroche. Dommage, il était 17h59 un vendredi,
les étudiants n'ont pas voulu qu'on le fasse proprement pour faire une
photo du tableau :) 
\end{Reponse}

\medskip
\noindent\begin{minipage}{.63\linewidth}
  \Exercice \textbf{Tri par sélection} (d'après Alexandre Miquel).

  On considère le code ci-contre, qui trie un tableau d'entier.

  Dans la logique de Hoare, t[i] ne peut être accédé que si la condition
  suivante est satisfaite: $O\leq i<taille(t)$.


  \Question Réécrivez ce programme en changeant les boucles \texttt{for} en
  boucles \texttt{while} équivalentes.

\end{minipage}\hfill%
\begin{minipage}{.3\linewidth}
\begin{Verbatim}[label=SEL]
for i := 0 to n-2 do
  for j := i+1 to n-1 do
    if t[j] < t[i] then 
      tmp := t[i]
      t[i] := t[j]
      t[j] := tmp
    end
  done
done
\end{Verbatim}  
\end{minipage}

\Question Montrez la correction du code de la permutation circulaire:\\
\centerline{$\{t[i]=x\wedge t[j]=y\} 
      ~tmp := t[i];
      t[i] := t[j];
      t[j] := tmp~ 
   \{t[i]=y\wedge t[j]=x\}$}

\Question Montrez à l'aide de ce qui précède la correction de l'algorithme du
tri par sélection.

\begin{Reponse}
  Pour de vrai, je n'ai jamais calculé le WP de cet algorithme-ci.
\end{Reponse}

\end{document}
%%% Local Variables:
%%% coding: latin-1
